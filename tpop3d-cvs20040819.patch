Index: tpop3d/CHANGES
diff -u tpop3d/CHANGES:1.83 tpop3d/CHANGES:1.88
--- tpop3d/CHANGES:1.83	Mon Nov 24 20:00:56 2003
+++ tpop3d/CHANGES	Tue Feb  3 19:52:02 2004
@@ -1,5 +1,15 @@
 Changes for tpop3d
-$Id$
+$Id$
+
+Removed the test which ignored messages in a maildir having modification times
+in the future, replacing it with a warning about possible clock synchronisation
+errors, following a suggestion of Matthew Trent. Fixed a (recently-introduced)
+bug in the maildir code which could cause a segmentation fault on misconfigured
+systems. Made a minor change to the way multi-line responses are transmitted,
+which may help some broken clients to work with tpop3d. Made some changes to
+the transmission of messages which may improve performance for clients on very
+fast networks, and added a tcp-send-buffer configuration option to control the
+SO_SNDBUF socket parameter.
 
 1.5.3
 
Index: tpop3d/README
diff -u tpop3d/README:1.22 tpop3d/README:1.23
--- tpop3d/README:1.22	Mon Nov 24 19:59:13 2003
+++ tpop3d/README	Tue Feb  3 19:52:02 2004
@@ -1,7 +1,7 @@
 tpop3d, copyright (c) 2000-2003 Chris Lightfoot <chris@ex-parrot.com>
   http://www.ex-parrot.com/~chris/tpop3d/
 
-$Id$
+$Id$
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -23,6 +23,7 @@
     auth-mysql          a vmail-sql style MySQL database; see
                             http://www.ex-parrot.com/~chris/vmail-sql/
                         or another database with user-specified SQL queries
+    auth-pgsql          a PostgreSQL database
     auth-ldap           an LDAP directory
     auth-flatfile       /etc/passwd-style flat files
     auth-other          an external program
Index: tpop3d/TODO
diff -u tpop3d/TODO:1.46 tpop3d/TODO:1.48
--- tpop3d/TODO:1.46	Mon Nov 24 19:58:28 2003
+++ tpop3d/TODO	Sun Jun 20 00:06:30 2004
@@ -1,5 +1,5 @@
 Things To Do
-$Id$
+$Id$
 
 * A proper code audit
 
@@ -96,3 +96,18 @@
 
 * Latency vs. throughput tradeoff under high load?
 
+* Deferred writes in connection_sendmessage -- that should bring the cost of
+  sending messages down to the cost of substituting \r\n for \n, etc.
+
+* Configurable (or adaptive?) SO_SNDBUF
+  We probably don't have enough information to measure the necessary
+  parameters (though in principle we could measure the delay between sending
+  +OK... and receiving a new command), so just make this a config file option.
+
+* NTLM authentication
+
+* STLS+APOP issue (email of 20040306)
+
+* Repeated messages (email of 20040325)
+
+* Maildir semantics (email of 20040331)
Index: tpop3d/auth_flatfile.c
diff -u tpop3d/auth_flatfile.c:1.2 tpop3d/auth_flatfile.c:1.3
--- tpop3d/auth_flatfile.c:1.2	Mon Feb 17 23:18:32 2003
+++ tpop3d/auth_flatfile.c	Sun Jun 20 00:06:30 2004
@@ -11,7 +11,7 @@
 #endif /* HAVE_CONFIG_H */
 
 #ifdef AUTH_FLATFILE
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h>
 
@@ -86,7 +86,7 @@
  * second field to the password hash. Any subsequent fields are ignored. */
 static char *read_user_passwd(const char *local_part, const char *domain) {
     FILE *fp = NULL;
-    char *filename = NULL;
+    char *filename = NULL, *result = NULL;
     struct sverr err;
     static char *buf, *pwhash;
     static size_t buflen;
@@ -149,6 +149,8 @@
         if ((end = strchr(pwhash, ':')))
             *end = 0;
 
+        result = pwhash;
+
         break;
     }
     
@@ -159,7 +161,7 @@
     if (filename)
         xfree(filename);
 
-    return pwhash;
+    return result;
 }
 
 /* auth_flatfile_new_user_pass:
Index: tpop3d/auth_mysql.c
diff -u tpop3d/auth_mysql.c:1.54 tpop3d/auth_mysql.c:1.55
--- tpop3d/auth_mysql.c:1.54	Mon Jul 14 23:31:20 2003
+++ tpop3d/auth_mysql.c	Fri Dec 12 12:05:50 2003
@@ -11,7 +11,7 @@
 #endif /* HAVE_CONFIG_H */
 
 #ifdef AUTH_MYSQL
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h> /* BSD needs this here, apparently. */
 
@@ -267,7 +267,7 @@
 
                 /* User was not lying (about her password) */
                 if (!parse_uid((const char*)row[2], &uid)) {
-                    log_print(LOG_ERR, _("auth_mysql_new_apop: unix user `%s' for %s does not make sense"), row[3], who);
+                    log_print(LOG_ERR, _("auth_mysql_new_apop: unix user `%s' for %s does not make sense"), row[2], who);
                     break;
                 }
 
@@ -367,7 +367,7 @@
                 }
 
                 if (!parse_uid((const char*)row[2], &uid)) {
-                    log_print(LOG_ERR, _("auth_mysql_new_user_pass: unix user `%s' for %s does not make sense"), row[3], who);
+                    log_print(LOG_ERR, _("auth_mysql_new_user_pass: unix user `%s' for %s does not make sense"), row[2], who);
                     break;
                 }
 
Index: tpop3d/authswitch.c
diff -u tpop3d/authswitch.c:1.42 tpop3d/authswitch.c:1.43
--- tpop3d/authswitch.c:1.42	Mon Nov 24 19:58:28 2003
+++ tpop3d/authswitch.c	Tue Feb  3 19:52:02 2004
@@ -6,7 +6,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -330,7 +330,7 @@
 #ifdef USE_WHOSON
     char buf[128] = {0};
     /* Notify whoson server the user has logged in correctly */
-    if (wso_login(clienthost, A->user, buf, sizeof(buf)) == -1)
+    if (whoson_enable && wso_login(clienthost, A->user, buf, sizeof(buf)) == -1)
         log_print(LOG_ERR, "authswitch_onlogin: wso_login: %s", buf);
 #endif /* USE_WHOSON */
     
Index: tpop3d/cfgdirectives.c
diff -u tpop3d/cfgdirectives.c:1.26 tpop3d/cfgdirectives.c:1.27
--- tpop3d/cfgdirectives.c:1.26	Mon Nov 24 19:58:28 2003
+++ tpop3d/cfgdirectives.c	Tue Feb  3 19:52:03 2004
@@ -9,7 +9,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -25,6 +25,7 @@
     "append-domain",
     "strip-domain",
     "timeout-seconds",
+    "tcp-send-buffer",
     "log-facility",
     "log-stderr",
     "apop-only",
Index: tpop3d/connection.c
diff -u tpop3d/connection.c:1.52 tpop3d/connection.c:1.55
--- tpop3d/connection.c:1.52	Thu Nov  6 01:19:27 2003
+++ tpop3d/connection.c	Tue Feb  3 19:52:03 2004
@@ -6,7 +6,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -127,7 +127,7 @@
 
     /* Read and write buffers */
     c->rdb = buffer_new(1024);
-    c->wrb = buffer_new(1024);
+    c->wrb = buffer_new(32768);
 
     c->timestamp = make_timestamp(c->domain);
     if (!c->timestamp) goto fail;
@@ -238,7 +238,8 @@
         } /* else IOABS_WOULDBLOCK */
     }
 
-    buffer_push_data(c->wrb, data, len);
+    if (len > 0)
+        buffer_push_data(c->wrb, data, len);
         /* XXX should try a write from the buffer now...? */
     return 1;
 }
@@ -416,7 +417,18 @@
  * Send an arbitrary line to a connected peer. Returns 1 on success or 0 on
  * failure. Used to send multiline responses. */
 int connection_sendline(connection c, const char *s) {
-    return connection_send(c, s, strlen(s)) && connection_send(c, "\r\n", 2);
+    /* Buffer copy, for reasons as given in connection_sendresponse. */
+    static char *buf;
+    static size_t buflen;
+    size_t l;
+    
+    l = strlen(s) + 2;
+    
+    if (!buf || buflen < l + 1)
+        buf = xrealloc(buf, buflen = l + 1);
+
+    sprintf(buf, "%s\r\n", s);
+    return connection_send(c, buf, l);
 }
 
 /* connection_sendmessage:
@@ -439,7 +451,42 @@
     char *p, *q, *r;
     size_t length, offset;
     ssize_t nwritten = 0;
-    
+    /* Doing lots of small writes is bad for performance, so buffer here and
+     * only write data when we've accumulated a large chunk of data. Use our
+     * own buffer here, rather than the connection IO buffer, since we don't
+     * want to use as much memory as a single message. */
+    static char *buffer;
+    static size_t buflen;
+    char *bufptr, *msg = NULL;
+
+    if (!buffer) buffer = xmalloc(buflen = 32768);
+    bufptr = buffer;
+
+#define buffer_push(sa, na) \
+        do { \
+            char *s; \
+            size_t n; \
+            s = sa; \
+            n = na; \
+            /* Unlikely but must deal with this case. */ \
+            if (n > buflen) { \
+                if (bufptr > buffer && !connection_send(c, buffer, bufptr - buffer)) \
+                    goto write_failure; \
+                bufptr = buffer; \
+                if (!connection_send(c, s, n)) \
+                    goto write_failure; \
+            } else { \
+                if ((bufptr + n) > (buffer + buflen)) { \
+                    if (!connection_send(c, buffer, bufptr - buffer)) \
+                        goto write_failure; \
+                    bufptr = buffer; \
+                } \
+                memcpy(bufptr, s, n); \
+                bufptr += n; \
+            } \
+            nwritten += n; \
+        } while (0)
+
     offset = msgoffset - (msgoffset % PAGESIZE);
     length = (msgoffset + msglength + PAGESIZE) ;
     length -= length % PAGESIZE;
@@ -451,8 +498,9 @@
         return -1; /* Failure before +OK sent. */
     }
 
-    connection_sendresponse(c, 1, _("Message follows"));
-    
+    msg = _("+OK Message follows\r\n");
+    buffer_push(msg, strlen(msg));
+
     /* Find the beginning of the message headers */
     p = filemem + (msgoffset % PAGESIZE);
     r = p + msglength;
@@ -465,14 +513,12 @@
         errno = 0;
         
         /* Escape a leading ., if present. */
-        if (*p == '.' && !connection_send(c, ".", 1))
-            goto write_failure;
-        ++nwritten;
+        if (*p == '.')
+            buffer_push(".", 1);
         
         /* Send line itself. */
-        if (!connection_send(c, p, q - p) || !connection_send(c, "\r\n", 2))
-            goto write_failure;
-        nwritten += q - p + 2;
+        buffer_push(p, q - p);
+        buffer_push("\r\n", 2);
 
         p = q + 1;
     }
@@ -480,11 +526,7 @@
     ++p;
 
     errno = 0;
-    if (!connection_send(c, "\r\n", 2)) {
-        log_print(LOG_ERR, _("connection_sendmessage: send failure"));
-        munmap(filemem, length);
-        return -2;
-    }
+    buffer_push("\r\n", 2);
     
     /* Now send the message itself */
     while (p < r && n) {
@@ -495,27 +537,31 @@
         errno = 0;
 
         /* Escape a leading ., if present. */
-        if (*p == '.' && !connection_send(c, ".", 1))
-            goto write_failure;
-        ++nwritten;
+        if (*p == '.')
+            buffer_push(".", 1);
         
         /* Send line itself. */
-        if (!connection_send(c, p, q - p) || !connection_send(c, "\r\n", 2))
-            goto write_failure;
-        nwritten += q - p + 2;
+        buffer_push(p, q - p);
+        buffer_push("\r\n", 2);
 
         p = q + 1;
     }
+
+    /* Finish up. */
+    buffer_push(".\r\n", 3);
+
+    if (bufptr > buffer && !connection_send(c, buffer, bufptr - buffer))
+        goto write_failure;
+    
     if (munmap(filemem, length) == -1)
         log_print(LOG_ERR, "connection_sendmessage: munmap: %m");
     
     errno = 0;
 
-    if (!connection_send(c, ".\r\n", 3)) {
-        log_print(LOG_ERR, _("connection_sendmessage: send failure"));
-        return -2;
-    } else return nwritten + 3;
+    return nwritten + 3;
 
+#undef buffer_push
+    
 write_failure:
     log_print(LOG_ERR, _("connection_sendmessage: send failure"));
     munmap(filemem, length);
Index: tpop3d/ioabs_tls.c
diff -u tpop3d/ioabs_tls.c:1.14 tpop3d/ioabs_tls.c:1.15
--- tpop3d/ioabs_tls.c:1.14	Mon Nov 24 19:58:28 2003
+++ tpop3d/ioabs_tls.c	Sun Jun 20 00:06:30 2004
@@ -11,7 +11,7 @@
 
 #ifdef USE_TLS
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h>
 
@@ -276,14 +276,12 @@
                     return 0;
 
                 case SSL_ERROR_SYSCALL:
-                    if (!e) {
-                        if (ERR_get_error() == 0)
-                            log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: connection unexpectedly closed by peer"), c->idstr);
-                        else
-                            log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: %m; closing connection"), c->idstr);
-                        break;
-                    }
-                    /* fall through */
+                    if (ERR_get_error() == 0)
+                        log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: connection unexpectedly closed by peer"), c->idstr);
+                    else
+                        log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: %m; closing connection"), c->idstr);
+                    break;
+                        
                 case SSL_ERROR_SSL:
                 default:
                     log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: %s; closing connection"), c->idstr, ERR_reason_error_string(ERR_get_error()));
Index: tpop3d/maildir.c
diff -u tpop3d/maildir.c:1.19 tpop3d/maildir.c:1.24
--- tpop3d/maildir.c:1.19	Mon Nov 24 20:23:20 2003
+++ tpop3d/maildir.c	Tue Feb  3 19:52:03 2004
@@ -13,7 +13,7 @@
 
 #ifdef MBOX_MAILDIR
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h>
 
@@ -148,7 +148,7 @@
  * Build an index of the MAILDIR; SUBDIRis one of cur, tmp or new; TIME is the
  * time at which the operation started, used to ignore messages delivered
  * during processes. Returns 0 on success, -1 otherwise. */
-int maildir_build_index(mailbox M, const char *subdir, time_t time) {
+int maildir_build_index(mailbox M, const char *subdir, time_t T) {
     DIR *dir;
     struct dirent *d;
 
@@ -156,7 +156,7 @@
 
     dir = opendir(subdir);
     if (!dir) {
-        log_print(LOG_ERR, "maildir_build_index: opendir(%s): %m", subdir);
+        log_print(LOG_ERR, "maildir_build_index: opendir(%s/%s): %m", M->name, subdir);
         return -1;
     }
     
@@ -168,11 +168,19 @@
         filename = xmalloc(strlen(subdir) + strlen(d->d_name) + 2);
         sprintf(filename, "%s/%s", subdir, d->d_name);
         if (!filename) return -1;
-        if (stat(filename, &st) == 0 && st.st_mtime < time) {
-            /* These get sorted by mtime later. */
+        if (0 == stat(filename, &st)) {
             struct indexpoint pt;
+
+            /* XXX Previously, we ignored messages from the future, since
+             * that's what qmail-pop3d does. But it's not clear why this is
+             * useful, so turn the check into a warning. */
+            if (st.st_mtime > T)
+                log_print(LOG_WARNING, _("maildir_build_index: %s: mtime is %d seconds in the future; this condition may indicate that you have a clock synchronisation error, especially if you are using NFS-mounted mail directories"), filename, (int)(st.st_mtime - T));
+            
+            /* These get sorted by mtime later. */
             maildir_make_indexpoint(&pt, filename, st.st_size, st.st_mtime);
             mailbox_add_indexpoint(M, &pt);
+
             /* Accumulate size of messages. */
             M->totalsize += st.st_size;
         }
@@ -205,7 +213,7 @@
     mailbox M, failM = NULL;
     struct timeval tv1, tv2;
     float f;
-    int locked;
+    int locked = 0;
  
     alloc_struct(_mailbox, M);
     
Index: tpop3d/netloop.c
diff -u tpop3d/netloop.c:1.10 tpop3d/netloop.c:1.12
--- tpop3d/netloop.c:1.10	Mon Nov 24 19:58:28 2003
+++ tpop3d/netloop.c	Sun Jun 20 00:06:30 2004
@@ -7,7 +7,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -41,7 +41,7 @@
 /* The socket send buffer is set to this, so that we don't end up in a
  * position that we send so much data that the client will not have received
  * all of it before we time them out. */
-#define MAX_DATA_IN_FLIGHT      8192
+#define DEFAULT_TCP_SEND_BUFFER     16384
 
 int max_running_children = 16;          /* How many children may exist at once. */
 volatile int num_running_children = 0;  /* How many children are active. */
@@ -124,9 +124,20 @@
         if (FD_ISSET(L->s, readfds)) {
             struct sockaddr_in sin, sinlocal;
             size_t l = sizeof(sin);
-            int s, a = MAX_DATA_IN_FLIGHT;
+            static int tcp_send_buf = -1;
+            int s;
             time_t start;
 
+            if (tcp_send_buf == -1) {
+                int q;
+                q = config_get_int("tcp-send-buffer", &tcp_send_buf);
+                if (q <= 0 || tcp_send_buf < 0) {
+                    tcp_send_buf = DEFAULT_TCP_SEND_BUFFER;
+                    if (q == -1 || tcp_send_buf < 0)
+                        log_print(LOG_WARNING, "listeners_post_select: bad value for tcp-send-buffer; using default");
+                }
+            }
+
             time(&start);
             errno = 0;
             
@@ -144,7 +155,8 @@
                     close(s);
                 }
 #endif
-                else if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &a, sizeof(a)) == -1) {
+                else if (tcp_send_buf != 0
+                         && setsockopt(s, SOL_SOCKET, SO_SNDBUF, &tcp_send_buf, sizeof(tcp_send_buf)) == -1) {
                     /* Set a small send buffer so that we get EAGAIN if the client
                      * isn't acking our data. */
                     log_print(LOG_ERR, "listeners_post_select: setsockopt: %m");
@@ -363,11 +375,11 @@
 /* connections_post_select:
  * Called after the main select(2) to do stuff with connections.
  *
- * For each connection, we call its own post_select routine. This will do all sorts
- * of stuff which is hidden to us, including pushing the running/closing/closed
- * state machine around and reading and writing the I/O buffers. We need to try to
- * parse commands when it's indicated that data have been read, and react to the
- * changed state of any connection. */
+ * For each connection, we call its own post_select routine. This will do all
+ * sorts of stuff which is hidden to us, including pushing the
+ * running/closing/closed state machine around and reading and writing the I/O
+ * buffers. We need to try to parse commands when it's indicated that data have
+ * been read, and react to the changed state of any connection. */
 static void connections_post_select(fd_set *readfds, fd_set *writefds, fd_set *exceptfds) {
     static size_t i;
     size_t i0;
@@ -382,12 +394,21 @@
         if (!(c = connections[i]))
             continue;
 
+        if (i > 0 && post_fork) {
+            connections[0] = c;
+            connections[i] = NULL;
+        }
+
         /* Handle all post-select I/O. */
         r = c->io->post_select(c, readfds, writefds, exceptfds);
 
         /* At this stage, the connection may be closed or closing. But we
          * should try to interpret commands anyway, in case the client sends
-         * QUIT and immediately closes the connection. */
+         * QUIT and immediately closes the connection.
+         * XXX That's not actually what we do. This creates a race condition
+         * with badly-behaved clients like Microsoft Outlook (cf. email of
+         * 20040203). We might want to consider an option to process remaining
+         * commands even if the connection is actually closed. */
         if (r && !connection_isfrozen(c)) {
             /*
              * Handling of POP3 commands, and forking children to handle
@@ -426,6 +447,15 @@
                     break;
             }
 
+            if (post_fork) {
+                if (i != 0) {
+                    connections[0] = connections[i];
+                    connections[i] = NULL;
+                }
+                i = 0;
+                break;
+            }
+
             if (!c)
                 continue; /* if connection has been destroyed, do next one */
         }
@@ -473,6 +503,11 @@
             if (post_fork)
                 _exit(0);
         }
+
+        if (post_fork) {
+            i = 0;
+            break;
+        }
     }
 }
 
@@ -503,12 +538,14 @@
     /* Main select() loop */
     while (!foad) {
         fd_set readfds, writefds;
-        struct timeval tv = {1, 0}; /* Must be less than IDLE_TIMEOUT and small enough that termination on receipt of SIGTERM is timely. */
+        struct timeval tv = {0};
         int n = 0, e;
 
         FD_ZERO(&readfds);
         FD_ZERO(&writefds);
 
+        tv.tv_sec = 1;  /* must be smaller than timeout */
+
         if (!post_fork) listeners_pre_select(&n, &readfds, &writefds, NULL);
 
         connections_pre_select(&n, &readfds, &writefds, NULL);
Index: tpop3d/pop3.c
diff -u tpop3d/pop3.c:1.57 tpop3d/pop3.c:1.58
--- tpop3d/pop3.c:1.57	Thu Nov  6 01:19:27 2003
+++ tpop3d/pop3.c	Tue Feb  3 19:52:03 2004
@@ -6,7 +6,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -295,10 +295,10 @@
             if (verbose)
                 log_print(LOG_DEBUG, _("do_retr: client %s: sending message %d (%d bytes)"),
                         c->idstr, msg_num + 1, (int)curmsg->msglength);
-        
+            
             if ((n = c->m->sendmessage(c->m, c, msg_num, -1)) == -2)
                 return close_connection;
-            
+
             /* That might have taken a long time. */
             c->idlesince = time(NULL);
             if (verbose) {
@@ -583,6 +583,9 @@
         }
         
         switch (p->cmd) {
+            case CAPA:
+                return do_capa(c);
+
             case LIST:
                 do_list(c, msg_num);
                 break;
Index: tpop3d/pop3bench
diff -u /dev/null tpop3d/pop3bench:1.3
--- /dev/null	Thu Aug 19 21:36:53 2004
+++ tpop3d/pop3bench	Tue Feb  3 19:52:03 2004
@@ -0,0 +1,370 @@
+#!/usr/bin/perl -w
+#
+# pop3bench:
+# POP3 server benchmarking tool.
+#
+# Copyright (c) 2004 Chris Lightfoot. All rights reserved.
+# Email: chris@ex-parrot.com; WWW: http://www.ex-parrot.com/~chris/
+#
+
+my $rcsid = ''; $rcsid .= '$Id$';
+
+use Digest::MD5;
+use IO::Socket;
+
+my $have_ssl = 0;
+eval '
+    use IO::Socket::SSL;
+    $have_ssl = 1;
+';
+
+use Time::HiRes;
+use Error qw(:try);
+
+my $T = time();
+
+sub howlong () {
+    my $T2 = time();
+    $T2 -= $T;
+    $T = time();
+    return $T2;
+}
+
+# error MESSAGE
+# Print the MESSAGE to stderr.
+sub error ($) {
+    print STDERR "pop3bench: $_[0]\n";
+}
+
+# quit MESSAGE
+# Print the MESSAGE to stderr and abort.
+sub quit ($) {
+    error($_[0]);
+    exit(1);
+}
+
+# verbose OPTIONS MESSAGE
+# If enabled, print a verbose MESSAGE to stderr.
+sub verbose ($$) {
+    error($_[1]) if ($_[0]->{verbose});
+}
+
+# usage
+# Print a usage message to stdout.
+sub usage () {
+    print <<EOF;
+pop3bench: POP3 server benchmarking tool
+
+Synopsis: pop3bench --help | [options] HOST [PORT]
+
+Options:
+    --help
+        Display this message.
+
+    --verbose
+        Log debugging information.
+
+    --conversation
+        Log the conversation between client and server. Implies --verbose.
+
+    --username USER
+    --password PASSWORD
+        Specify USER and PASSWORD for authentication. Default: ask
+        interactively.
+
+    --apop
+        Use the APOP shared-secret authentication method. Default: use
+        USER/PASS.
+
+    --pipelining
+        Use command pipelining, if supported. Default: don't.
+
+    --tls
+    --stls
+        Make a TLS connection to the server; or, connect to the server
+        normally, but attempt to negotiate TLS operation using the STLS
+        command. Default: use unsecured TCP.
+
+    --commands LIST
+        Benchmark the given comma-separated LIST of commands on the server.
+        LIST may include: LIST UIDL DELE RETR TOP NOOP. Benchmarking DELE is
+        destructive, obviously. Default: LIST, UIDL, RETR.
+
+In unsecured TCP and STLS modes, the default PORT is 110; in TLS mode the
+default PORT is 995.
+
+Copyright (c) 2004 Chris Lightfoot <chris\@ex-parrot.com>
+All Rights Reserved.
+EOF
+}
+
+# parse_options ARGUMENTS
+# Return a reference to a hash with the options to be used by the program.
+sub parse_options (@) {
+    my @args = @_;
+    my $res = {
+        port => undef,
+        mode => 'tcp',
+        apop => 0,
+        pipelining => 0,
+        user => undef,
+        pass => undef,
+        commands => [qw(list uidl retr)],
+        verbose => 0,
+        conversation => 0
+    };
+    
+    while (@args && $args[0] =~ /^--(.+)/) {
+        shift(@args);
+        if ($1 eq 'help') {
+            usage();
+            exit(0);
+        } elsif ($1 eq 'verbose') {
+            $res->{verbose} = 1;
+        } elsif ($1 eq 'conversation') {
+            $res->{conversation} = $res->{verbose} = 1;
+        } elsif ($1 eq 'username') {
+            $res->{user} = shift(@args);
+        } elsif ($1 eq 'password') {
+            $res->{pass} = shift(@args);
+        } elsif ($1 eq 'apop') {
+            $res->{apop} = 1;
+        } elsif ($1 eq 'pipelining') {
+            $res->{pipelining} = 1;
+        } elsif ($1 eq 'commands') {
+            my %allowed = map { $_ => 1 } qw(list uidl dele retr top noop);
+            $res->{commands} = [ ];
+            foreach (split(/,\s*/, shift(@args))) {
+                $_ = lc($_);
+                return "`$_' is not a known command" unless (exists($allowed{$_}));
+                push(@{$res->{commands}}, $_);
+            }
+        } elsif ($1 =~ /^(s?tls)$/) {
+            return "specify at most one of --tls, --stls" if ($res->{mode} ne 'tcp');
+            $res->{mode} = $1;
+        } else {
+            return "`--$1': unknown option";
+        }
+    }
+
+    return "arguments are host and optional port" if (@args > 2 || @args == 0);
+
+    $res->{host} = shift(@args);
+    $res->{port} = shift(@args) if (@args);
+
+    # Default port differs between TCP and TLS modes.
+    if (!defined($res->{port})) {
+        if ($res->{mode} eq 'tls') {
+            $res->{port} = 995;
+        } else {
+            $res->{port} = 110;
+        }
+    }
+
+    return $res;
+}
+
+# get_pop3_line OPTIONS SOCKET
+# Return a POP3 response line read from SOCKET, or undef on failure.
+sub get_pop3_line ($$) {
+    my ($opts, $s) = @_;
+    local $/ = "\r\n";
+    my $x = $s->getline() or throw Error::Simple("read: $!");
+    chomp($x);
+    return $x;
+}
+
+# get_pop3_resp OPTIONS SOCKET
+# Get a POP3 response line, and return 1 if it starts +OK, 0 if -ERR, or throw
+# an exception on error.
+sub get_pop3_resp ($$) {
+    my ($opts, $s) = @_;
+    my $r = get_pop3_line($opts, $s);
+    verbose($opts, "<-- $r") if ($opts->{conversation});
+    if ($r =~ /^\+OK/) {
+        return 1;
+    } elsif ($r =~ /^-ERR/) {
+        return 0;
+    } else {
+        throw Error::Simple("bad response line `$r'");
+    }
+}
+
+# send_pop3_cmd OPTIONS SOCKET COMMAND
+# Send COMMAND to SOCKET.
+sub send_pop3_cmd ($$$) {
+    my ($opts, $s, $cmd) = @_;
+    $s->print("$cmd\r\n") or throw Error::Simple("write: $!");
+    if ($opts->{conversation}) {
+        if ($cmd =~ /^PASS /i) {
+            verbose($opts, "--> PASS [...]");
+        } else {
+            verbose($opts, "--> $cmd");
+        }
+    }
+}
+
+# get_pop3_multiline_resp OPTIONS SOCKET [DISCARD]
+# Get a multiline response from the server. If DISCARD is true, just count the
+# lines and return the total. Otherwise return the response as a list of lines.
+# DISCARD is assumed to be true when called in scalar context;
+sub get_pop3_multiline_resp ($$;$) {
+    my ($opts, $s, $discard) = @_;
+    $discard ||= wantarray;
+    throw Error::Simple("bad response") if (!get_pop3_resp($opts, $s));
+    my @list;
+    my $N = 0;
+    while (($_ = get_pop3_line($opts, $s)) ne '.') {
+        if ($discard) {
+            ++$N;
+        } else {
+            push(@list, $_);
+        }
+    }
+    if ($opts->{conversation}) {
+        verbose($opts, "<-- ... " . scalar(@list) . " lines ...");
+        verbose($opts, "<-- .");
+    }
+    if ($discard) {
+        return $N;
+    } else {
+        return @list;
+    }
+}
+
+# connect_to_server OPTIONS
+# Return a socket connected to the server, per OPTIONS.
+sub connect_to_server ($) {
+    my $opts = shift;
+    my $s;
+    verbose($opts, "connecting to $opts->{host}:$opts->{port}");
+    if ($opts->{mode} ne 'tls') {
+        $s = new IO::Socket::INET("$opts->{host}:$opts->{port}");
+    } else {
+        $s = new IO::Socket::SSL("$opts->{host}:$opts->{port}");
+    }
+    
+    throw Error::Simple("connect: $!") unless (defined($s));
+
+    try {
+        my $banner = get_pop3_line($opts, $s);
+        if (!$banner) {
+            throw Error::Simple("no banner response from server");
+        } elsif ($banner !~ /^\+OK/) {
+            throw Error::Simple("bad banner response `$banner'");
+        }
+
+        if ($banner =~ m#<([^>]+)>#) {
+            $opts->{timestamp} = $1;
+        }
+
+        if ($opts->{mode} eq 'stls') {
+            verbose($opts, "enabling STLS mode");
+            send_pop3_cmd($opts, $s, "STLS");
+            if (!get_pop3_resp($opts, $s)) {
+                throw Error::Simple("negative STLS response");
+            } else {
+                verbose($opts, "beginning TLS negotiation");
+                IO::Socket::SSL->start_SSL($s);
+                if (ref($s) ne 'IO::Socket::SSL') {
+                    throw Error::Simple("TLS negotiation failed");
+                }
+                verbose($opts, "TLS negotiation successful");
+            }
+        }
+    } otherwise {
+        my $E = shift;
+        $s->close();
+        throw $E;
+    };
+
+    return $s;
+}
+
+# do_login OPTIONS SOCKET
+# Log in to the server by USER/PASS or APOP as appropriate. Return the number
+# of messages available, by doing a LIST.
+sub do_login ($$) {
+    my ($opts, $s) = @_;
+    if ($opts->{apop}) {
+        throw Error::Simple("can't do APOP login since server did not send a timestamp") if (!exists($opts->{timestamp}));
+        verbose($opts, "sending APOP login command");
+        my $digest = Digest::MD5::md5_hex($opts->{timestamp} . $opts->{user});
+        send_pop3_cmd($opts, $s, "APOP $opts->{user} $digest");
+        throw Error::Simple("negative APOP response (login failed)") if (!get_pop3_resp($opts, $s));
+    } else {
+        verbose($opts, "sending USER/PASS login commands");
+        send_pop3_cmd($opts, $s, "USER $opts->{user}");
+        send_pop3_cmd($opts, $s, "PASS $opts->{pass}") if ($opts->{pipelining});
+        throw Error::Simple("negative USER response") if (!get_pop3_resp($opts, $s));
+        send_pop3_cmd($opts, $s, "PASS $opts->{pass}") unless ($opts->{pipelining});
+        throw Error::Simple("negative PASS response (login failed)") if (!get_pop3_resp($opts, $s));
+    }
+    verbose($opts, "login successful; retrieving list of messages");
+    send_pop3_cmd($opts, $s, "LIST");
+    my $n = get_pop3_multiline_resp($opts, $s);
+    verbose($opts, "$n messages available");
+    return $n;
+}
+
+# do_quit OPTIONS SOCKET
+# Log out and shut down the connection on SOCKET.
+sub do_quit ($$) {
+    my ($opts, $s) = @_;
+    verbose($opts, "logging out");
+    send_pop3_cmd($opts, $s, "QUIT");
+    error("negative QUIT response (bad, not fatal)") if (!get_pop3_resp($opts, $s));
+    verbose($opts, "closing connection");
+    $s->shutdown(2);
+    $s->close();
+    verbose($opts, "done");
+}
+
+my $opts = parse_options(@ARGV);
+
+if (!ref($opts)) {
+    quit($opts);
+    exit(1);
+}
+
+if ($opts->{mode} ne 'tcp' && !$have_ssl) {
+    quit("$opts->{mode} requested, but no IO::Socket::SSL");
+}
+
+# If not specified on command line, get username and password.
+if (!defined($opts->{user})) {
+    $| = 1;
+    print "Username: ";
+    my $u = STDIN->getline();
+    quit("you must give a username") if (!defined($u));
+    chomp($u);
+    $u =~ s/^\s+//;
+    $u =~ s/\s+$//;
+    quit("you must give a username") if (length($u) == 0);
+    $| = 0;
+    $opts->{user} = $u;
+}
+
+if (!defined($opts->{pass})) {
+    $| = 1;
+    print "Password: ";
+    system("stty", "-echo");
+    my $p = STDIN->getline();
+    quit("you must give a password") if (!defined($p));
+    chomp($p);
+    $p =~ s/^\s+//;
+    $p =~ s/\s+$//;
+    system("stty", "echo");
+    print "\n";
+    $| = 0;
+    $opts->{pass} = $p;
+}
+
+try {
+    my $s = connect_to_server($opts);
+    do_login($opts, $s);
+    do_quit($opts, $s);
+} catch Error::Simple with {
+    my $E = shift;
+    quit($E->text());
+}
Index: tpop3d/tpop3d.conf.5
diff -u tpop3d/tpop3d.conf.5:1.47 tpop3d/tpop3d.conf.5:1.49
--- tpop3d/tpop3d.conf.5:1.47	Mon Nov 24 19:58:28 2003
+++ tpop3d/tpop3d.conf.5	Tue Feb  3 19:52:03 2004
@@ -5,7 +5,7 @@
 .\"
 .\" Copyright (c) 2001-2 Chris Lightfoot. All rights reserved.
 .\"
-.\" $Id$
+.\" $Id$
 .\"
 
 .\" Text begins
@@ -142,6 +142,16 @@
 timeout), then specify 600 seconds. This may be necessary with some clients
 which pause randomly whilst downloading messages.
 .TP
+\fBtcp-send-buffer\fp: \fInumber\fP
+This is the largest number of bytes which may be `in flight' between the server
+and a client at any time. Setting this to larger values may improve the
+performance of \fBtpop3d\fP, but at the risk of timing out clients connected by
+slow networks. You should not set this parameter to anything larger than the
+timeout multiplied by the data rate (in bytes per second) of the slowest
+network through which clients will connect to the POP3 server. This is set using
+the SO_SNDBUF socket option; see \fBsocket\fP(7) for more information. The
+default is 16,384 bytes; set this to 0 to use the system default.
+.TP
 \fBlog-facility\fP: \fIfacility\fP
 This selects the `facility' as which \fBtpop3d\fP emits system log messages.
 Possible values for \fIfacility\fP are: \fBmail\fP, \fBauthpriv\fP,
@@ -856,7 +865,7 @@
 .IR http://lists.beasts.org/pipermail/tpop3d-discuss/ .
 
 .SH VERSION
-$Id$
+$Id$
 
 .SH COPYING
 This program is free software; you can redistribute it and/or modify
