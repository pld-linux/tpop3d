Index: tpop3d/CHANGES
diff -u tpop3d/CHANGES:1.83 tpop3d/CHANGES:1.93
--- tpop3d/CHANGES:1.83	Mon Nov 24 20:00:56 2003
+++ tpop3d/CHANGES	Tue Oct  5 11:52:23 2004
@@ -1,5 +1,21 @@
 Changes for tpop3d
-$Id$
+$Id$
+
+Removed the test which ignored messages in a maildir having modification times
+in the future, replacing it with a warning about possible clock synchronisation
+errors, following a suggestion of Matthew Trent. Fixed a (recently-introduced)
+bug in the maildir code which could cause a segmentation fault on misconfigured
+systems. Made a minor change to the way multi-line responses are transmitted,
+which may help some broken clients to work with tpop3d. Made some changes to
+the transmission of messages which may improve performance for clients on very
+fast networks, and added a tcp-send-buffer configuration option to control the
+SO_SNDBUF socket parameter. Fixed a couple of memory leaks; thanks to Richard
+Fuchs and Daniel Tiefnig from Inode for identifying those and supplying a
+patch. The same authors also supplied code to enable recursion into subfolders
+of a maildir mailbox (maildir-recursion config option). Added support for SHA1
+passwords, and fixed a bug in the MD5 base64 password code. By default, commit
+changes on close-after-QUIT (`Microsoft Outlook bug' workaround), with an
+option to restore the previous, correct, behaviour.
 
 1.5.3
 
Index: tpop3d/INSTALL
diff -u tpop3d/INSTALL:1.22 tpop3d/INSTALL:1.23
--- tpop3d/INSTALL:1.22	Thu Jan  9 23:25:59 2003
+++ tpop3d/INSTALL	Wed Sep 29 20:57:59 2004
@@ -1,5 +1,5 @@
 Installation instructions for tpop3d
-$Id$
+$Id$
 
 Thanks to the efforts of Mark Longair, tpop3d can now be configured and built
 using the standard GNU autoconf approach. For most users, it should be
@@ -56,6 +56,7 @@
           {plaintext}...    plain text password used for APOP
           {mysql}...        password hashed using MySQL's PASSWORD()
           {md5}...          straight MD5 hash
+          {sha1}...         straight SHA1 hash
 
       Note that to use APOP, the plaintext password type must be specified for
       a user, but this does not stop them logging in via any other method with
Index: tpop3d/README
diff -u tpop3d/README:1.22 tpop3d/README:1.23
--- tpop3d/README:1.22	Mon Nov 24 19:59:13 2003
+++ tpop3d/README	Tue Feb  3 19:52:02 2004
@@ -1,7 +1,7 @@
 tpop3d, copyright (c) 2000-2003 Chris Lightfoot <chris@ex-parrot.com>
   http://www.ex-parrot.com/~chris/tpop3d/
 
-$Id$
+$Id$
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
@@ -23,6 +23,7 @@
     auth-mysql          a vmail-sql style MySQL database; see
                             http://www.ex-parrot.com/~chris/vmail-sql/
                         or another database with user-specified SQL queries
+    auth-pgsql          a PostgreSQL database
     auth-ldap           an LDAP directory
     auth-flatfile       /etc/passwd-style flat files
     auth-other          an external program
Index: tpop3d/README.auth_mysql
diff -u tpop3d/README.auth_mysql:1.7 tpop3d/README.auth_mysql:1.8
--- tpop3d/README.auth_mysql:1.7	Wed Nov  7 00:50:41 2001
+++ tpop3d/README.auth_mysql	Wed Sep 29 20:57:59 2004
@@ -1,5 +1,5 @@
 README for MySQL authentication in tpop3d
-$Id$
+$Id$
 
 The auth-mysql authentication driver was developed for use with the vmail-sql
 database schema for virtual domains, though it is easy to adjust for a
@@ -80,6 +80,7 @@
       {crypt_md5}...      crypt_md5 hash
       {plaintext}...      plaintext password
       {mysql}...          password hashed using MySQL's PASSWORD()
+      {sha1}              simple SHA1 password
       {md5} or no prefix  old-style simple MD5 password
 
    {crypt} is the format of the system crypt(3) function-- two salt characters
@@ -89,10 +90,11 @@
    in crypt(3), but for portability it is included as a separate case.
    {plaintext} is a password saved in plain text; this format is useful if you
    want to support authentication by the APOP shared-secret mechanism. {mysql}
-   is the format produced by the PASSWORD() function in MySQL.  {md5} is a
-   simple MD5 hash of the password, without salt, saved as a 32-character hex
-   string. This is the historical format for vmail-sql, and so is the default
-   if no prefix is used. This may go away at some point.
+   is the format produced by the PASSWORD() function in MySQL. {sha1} is a
+   simple 20-character hex SHA1 hash of the password. {md5} is a simple MD5
+   hash of the password, without salt, saved as a 32-character hex string or a
+   24-character base64 one. This is the historical format for vmail-sql, and so
+   is the default if no prefix is used. This may go away at some point.
 
    Now, we compare the user's password against the stored hash or password,
    and decide whether to authenticate the user or not. If this does not
Index: tpop3d/TODO
diff -u tpop3d/TODO:1.46 tpop3d/TODO:1.48
--- tpop3d/TODO:1.46	Mon Nov 24 19:58:28 2003
+++ tpop3d/TODO	Sun Jun 20 00:06:30 2004
@@ -1,5 +1,5 @@
 Things To Do
-$Id$
+$Id$
 
 * A proper code audit
 
@@ -96,3 +96,18 @@
 
 * Latency vs. throughput tradeoff under high load?
 
+* Deferred writes in connection_sendmessage -- that should bring the cost of
+  sending messages down to the cost of substituting \r\n for \n, etc.
+
+* Configurable (or adaptive?) SO_SNDBUF
+  We probably don't have enough information to measure the necessary
+  parameters (though in principle we could measure the delay between sending
+  +OK... and receiving a new command), so just make this a config file option.
+
+* NTLM authentication
+
+* STLS+APOP issue (email of 20040306)
+
+* Repeated messages (email of 20040325)
+
+* Maildir semantics (email of 20040331)
Index: tpop3d/auth_flatfile.c
diff -u tpop3d/auth_flatfile.c:1.2 tpop3d/auth_flatfile.c:1.3
--- tpop3d/auth_flatfile.c:1.2	Mon Feb 17 23:18:32 2003
+++ tpop3d/auth_flatfile.c	Sun Jun 20 00:06:30 2004
@@ -11,7 +11,7 @@
 #endif /* HAVE_CONFIG_H */
 
 #ifdef AUTH_FLATFILE
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h>
 
@@ -86,7 +86,7 @@
  * second field to the password hash. Any subsequent fields are ignored. */
 static char *read_user_passwd(const char *local_part, const char *domain) {
     FILE *fp = NULL;
-    char *filename = NULL;
+    char *filename = NULL, *result = NULL;
     struct sverr err;
     static char *buf, *pwhash;
     static size_t buflen;
@@ -149,6 +149,8 @@
         if ((end = strchr(pwhash, ':')))
             *end = 0;
 
+        result = pwhash;
+
         break;
     }
     
@@ -159,7 +161,7 @@
     if (filename)
         xfree(filename);
 
-    return pwhash;
+    return result;
 }
 
 /* auth_flatfile_new_user_pass:
Index: tpop3d/auth_mysql.c
diff -u tpop3d/auth_mysql.c:1.54 tpop3d/auth_mysql.c:1.56
--- tpop3d/auth_mysql.c:1.54	Mon Jul 14 23:31:20 2003
+++ tpop3d/auth_mysql.c	Thu Aug 19 23:57:05 2004
@@ -11,7 +11,7 @@
 #endif /* HAVE_CONFIG_H */
 
 #ifdef AUTH_MYSQL
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h> /* BSD needs this here, apparently. */
 
@@ -44,7 +44,7 @@
  *  [2] unix user
  *  [3] mailbox type
  */
-char *user_pass_query_template =
+static char *user_pass_query_template =
     "SELECT concat(domain.path, '/', popbox.mbox_name), popbox.password_hash, "
             "domain.unix_user, 'bsd' "
       "FROM popbox, domain "
@@ -52,7 +52,7 @@
        "AND popbox.domain_name = '$(domain)' "
        "AND popbox.domain_name = domain.domain_name";
        
-char *apop_query_template =
+static char *apop_query_template =
     "SELECT concat(domain.path, '/', popbox.mbox_name), popbox.password_hash, "
             "domain.unix_user, 'bsd' "
       "FROM popbox, domain "
@@ -60,20 +60,20 @@
        "AND popbox.domain_name = '$(domain)' "
        "AND popbox.domain_name = domain.domain_name";
 
-char *onlogin_query_template = NULL;
+static char *onlogin_query_template = NULL;
 
 /* GID used to access mail spool (if any). */
-int use_gid;
-gid_t mail_gid;
+static int use_gid;
+static gid_t mail_gid;
 
 static char *substitute_query_params(const char *temp, const char *user, const char *local_part, const char *domain, const char *clienthost, const char *serverhost);
 
 /*
  * Connection to the MySQL server.
  */
-MYSQL *mysql = NULL;
-tokens mysql_servers;
-char mysql_driver_active = 0;
+static MYSQL *mysql = NULL;
+static tokens mysql_servers;
+static char mysql_driver_active = 0;
 
 /* get_mysql_server:
  * If we are not currently connected to a MySQL server, or if the current MySQL
@@ -267,7 +267,7 @@
 
                 /* User was not lying (about her password) */
                 if (!parse_uid((const char*)row[2], &uid)) {
-                    log_print(LOG_ERR, _("auth_mysql_new_apop: unix user `%s' for %s does not make sense"), row[3], who);
+                    log_print(LOG_ERR, _("auth_mysql_new_apop: unix user `%s' for %s does not make sense"), row[2], who);
                     break;
                 }
 
@@ -367,7 +367,7 @@
                 }
 
                 if (!parse_uid((const char*)row[2], &uid)) {
-                    log_print(LOG_ERR, _("auth_mysql_new_user_pass: unix user `%s' for %s does not make sense"), row[3], who);
+                    log_print(LOG_ERR, _("auth_mysql_new_user_pass: unix user `%s' for %s does not make sense"), row[2], who);
                     break;
                 }
 
Index: tpop3d/auth_pgsql.c
diff -u tpop3d/auth_pgsql.c:1.1 tpop3d/auth_pgsql.c:1.2
--- tpop3d/auth_pgsql.c:1.1	Mon Jul 14 23:31:20 2003
+++ tpop3d/auth_pgsql.c	Thu Aug 19 23:57:05 2004
@@ -13,7 +13,7 @@
 #endif /* HAVE_CONFIG_H */
 
 #ifdef AUTH_PGSQL
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h> /* BSD needs this here, apparently. */
 
@@ -105,7 +105,7 @@
  *  [2] unix user
  *  [3] mailbox type
  */
-char *user_pass_query_template =
+static char *user_pass_query_template =
     "SELECT domain.path || '/'  || popbox.mbox_name, popbox.password_hash, "
             "domain.unix_user, 'bsd' "
       "FROM popbox, domain "
@@ -113,7 +113,7 @@
        "AND popbox.domain_name = '$(domain)' "
        "AND popbox.domain_name = domain.domain_name";
        
-char *apop_query_template =
+static char *apop_query_template =
     "SELECT domain.path || '/' || popbox.mbox_name, popbox.password_hash, "
             "domain.unix_user, 'bsd' "
       "FROM popbox, domain "
@@ -121,11 +121,11 @@
        "AND popbox.domain_name = '$(domain)' "
        "AND popbox.domain_name = domain.domain_name";
 
-char *onlogin_query_template = NULL;
+static char *onlogin_query_template = NULL;
 
 /* GID used to access mail spool (if any). */
-int use_gid;
-gid_t mail_gid;
+static int use_gid;
+static gid_t mail_gid;
 
 static char *substitute_query_params(const char *temp, const char *user, const char *local_part, const char *domain, const char *clienthost, const char *serverhost);
 
@@ -148,7 +148,7 @@
  * Initialise the database connection driver. Clears the config directives
  * associated with the database so that a user cannot recover them with a
  * debugger. */
-PGconn *pg_conn;
+static PGconn *pg_conn;
 
 int auth_pgsql_init(void) {
     char *username = NULL, *password = NULL, *hostname = NULL, *database = NULL, *localhost = "localhost", *s;
Index: tpop3d/authswitch.c
diff -u tpop3d/authswitch.c:1.42 tpop3d/authswitch.c:1.44
--- tpop3d/authswitch.c:1.42	Mon Nov 24 19:58:28 2003
+++ tpop3d/authswitch.c	Wed Sep 15 19:26:28 2004
@@ -6,7 +6,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -290,25 +290,26 @@
             l = NULL;
     }
 
-    if ((a = authcache_new_user_pass(user, l, d, pass, clienthost, serverhost)))
-        return a;
-
-    for (aa = auth_drivers, aar = auth_drivers_running; aa < auth_drivers_end; ++aa, ++aar)
-        if (*aar && aa->auth_new_user_pass && (a = aa->auth_new_user_pass(user, l, d, pass, clienthost, serverhost))) {
-            a->auth = xstrdup(aa->name);
-            a->user = xstrdup(user);
-            if (!a->local_part) {
-                if (l)
-                    a->local_part = xstrdup(l);
-                else
-                    a->local_part = xstrdup(user);
+    /* Try auth cache, then actual auth drivers. */
+    if (!(a = authcache_new_user_pass(user, l, d, pass, clienthost, serverhost))) {
+        for (aa = auth_drivers, aar = auth_drivers_running; aa < auth_drivers_end; ++aa, ++aar) {
+            if (*aar && aa->auth_new_user_pass && (a = aa->auth_new_user_pass(user, l, d, pass, clienthost, serverhost))) {
+                a->auth = xstrdup(aa->name);
+                a->user = xstrdup(user);
+                if (!a->local_part) {
+                    if (l)
+                        a->local_part = xstrdup(l);
+                    else
+                        a->local_part = xstrdup(user);
+                }
+                if (!a->domain && d)
+                    a->domain = xstrdup(d);
+                authcache_save(a, user, l, d, pass, clienthost, serverhost);
+                log_print(LOG_INFO, _("authcontext_new_user_pass: began session for `%s' with %s; uid %d, gid %d"), a->user, a->auth, a->uid, a->gid);
+                break;
             }
-            if (!a->domain && d)
-                a->domain = xstrdup(d);
-            authcache_save(a, user, l, d, pass, clienthost, serverhost);
-            log_print(LOG_INFO, _("authcontext_new_user_pass: began session for `%s' with %s; uid %d, gid %d"), a->user, a->auth, a->uid, a->gid);
-            break;
         }
+    }
 
     xfree(x);
     
@@ -330,7 +331,7 @@
 #ifdef USE_WHOSON
     char buf[128] = {0};
     /* Notify whoson server the user has logged in correctly */
-    if (wso_login(clienthost, A->user, buf, sizeof(buf)) == -1)
+    if (whoson_enable && wso_login(clienthost, A->user, buf, sizeof(buf)) == -1)
         log_print(LOG_ERR, "authswitch_onlogin: wso_login: %s", buf);
 #endif /* USE_WHOSON */
     
Index: tpop3d/cfgdirectives.c
diff -u tpop3d/cfgdirectives.c:1.26 tpop3d/cfgdirectives.c:1.29
--- tpop3d/cfgdirectives.c:1.26	Mon Nov 24 19:58:28 2003
+++ tpop3d/cfgdirectives.c	Tue Oct  5 11:51:21 2004
@@ -9,7 +9,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -25,6 +25,7 @@
     "append-domain",
     "strip-domain",
     "timeout-seconds",
+    "tcp-send-buffer",
     "log-facility",
     "log-stderr",
     "apop-only",
@@ -33,6 +34,7 @@
     "permit-empty-passwords",
     "onlogin-child-wait",
     "log-bad-passwords",
+    "no-commit-on-early-close",
  
 #if defined(MBOX_BSD) && defined(MBOX_BSD_SAVE_INDICES)
     "mailspool-index",
@@ -52,6 +54,8 @@
     
 #ifdef MBOX_MAILDIR
     "maildir-exclusive-lock",
+    "maildir-recursion",
+    "maildir-ignore-folders",
 #endif
 
 #ifdef USE_TLS
Index: tpop3d/configure.in
diff -u tpop3d/configure.in:1.58 tpop3d/configure.in:1.59
--- tpop3d/configure.in:1.58	Mon Nov 24 19:59:13 2003
+++ tpop3d/configure.in	Wed Sep 29 20:57:59 2004
@@ -6,7 +6,7 @@
 dnl
 dnl Copyright (c) 2001 Mark Longair, Chris Lightfoot. All Rights Reserved.
 dnl
-dnl $Id$
+dnl $Id$
 dnl
 
 AC_INIT(auth_mysql.c)
@@ -108,7 +108,7 @@
     [pgsql_include_dir="/usr/include"])
 
 AC_ARG_WITH(pgsql-lib-dir,
-        [    --with-pgsql-lib-dir=DIR  Set Postgreslibrary directory, which should
+        [    --with-pgsql-lib-dir=DIR  Set Postgres library directory, which should
                               contain libpq.so. [default=/usr/lib]
 ],
     [pgsql_lib_dir=$withval],
@@ -283,6 +283,16 @@
     [enable_masshosting=$enableval],
     [enable_masshosting=yes])
 
+dnl SHA1 passwords
+AC_ARG_ENABLE(sha1-passwords,
+        [  --disable-sha1-passwords
+                          Don't allow the SHA1 message digest algorithm to to
+                          be used for password hashes. The only reason to do so
+                          is if you don't want tpop3d to be linked against
+                          OpenSSL.
+],
+    [enable_sha1_passwords=$enableval],
+    [enable_sha1_passwords=yes])
 
 dnl Some options mainly useful for development/debugging.
 
@@ -452,6 +462,11 @@
 then
     AC_DEFINE(MASS_HOSTING,1,[Enable regex matching of inverse DNS results for domain names])
 fi
+
+if test x"$enable_sha1_passwords" = x"yes"
+then
+    AC_DEFINE(SHA1_PASSWORDS,1,[Enable SHA1-format password hashes])
+fi
     
 if test x"$enable_backtrace" = x"yes"
 then
@@ -556,9 +571,9 @@
 fi
 
 # OpenSSL
-if test x"$enable_tls" = x"yes"
+if test x"$enable_tls" = x"yes" || test x"$enable_sha1_passwords" = x"yes"
 then
-    AC_CHECK_LIB2(ssl, SSL_new, [], AC_MSG_ERROR([[TLS enabled, but can't find libssl]]), -lcrypto)
+    AC_CHECK_LIB2(ssl, SSL_new, [], AC_MSG_ERROR([[TLS/SHA1 passwords enabled, but can't find libssl]]), -lcrypto)
 fi
 
 # Where is nanosleep?
Index: tpop3d/connection.c
diff -u tpop3d/connection.c:1.52 tpop3d/connection.c:1.56
--- tpop3d/connection.c:1.52	Thu Nov  6 01:19:27 2003
+++ tpop3d/connection.c	Wed Sep 15 19:26:28 2004
@@ -6,7 +6,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -127,7 +127,7 @@
 
     /* Read and write buffers */
     c->rdb = buffer_new(1024);
-    c->wrb = buffer_new(1024);
+    c->wrb = buffer_new(32768);
 
     c->timestamp = make_timestamp(c->domain);
     if (!c->timestamp) goto fail;
@@ -238,7 +238,8 @@
         } /* else IOABS_WOULDBLOCK */
     }
 
-    buffer_push_data(c->wrb, data, len);
+    if (len > 0)
+        buffer_push_data(c->wrb, data, len);
         /* XXX should try a write from the buffer now...? */
     return 1;
 }
@@ -302,8 +303,10 @@
      * latter case we must be careful not to interpret command1\ncommand2\r\n
      * as a single command. So always use \n as the line ending and strip off
      * any trailing \r. */
-    if (!(line = buffer_consume_to_mark(c->rdb, "\n", 1, line, &llen)))
+    if (!(p = buffer_consume_to_mark(c->rdb, "\n", 1, line, &llen)))
         return NULL;
+    else
+        line = p;
 
     /* remove trailing eol */
     for (i = llen - 1; i > 0 && strchr("\r\n", line[i]); --i)
@@ -416,7 +419,18 @@
  * Send an arbitrary line to a connected peer. Returns 1 on success or 0 on
  * failure. Used to send multiline responses. */
 int connection_sendline(connection c, const char *s) {
-    return connection_send(c, s, strlen(s)) && connection_send(c, "\r\n", 2);
+    /* Buffer copy, for reasons as given in connection_sendresponse. */
+    static char *buf;
+    static size_t buflen;
+    size_t l;
+    
+    l = strlen(s) + 2;
+    
+    if (!buf || buflen < l + 1)
+        buf = xrealloc(buf, buflen = l + 1);
+
+    sprintf(buf, "%s\r\n", s);
+    return connection_send(c, buf, l);
 }
 
 /* connection_sendmessage:
@@ -439,7 +453,42 @@
     char *p, *q, *r;
     size_t length, offset;
     ssize_t nwritten = 0;
-    
+    /* Doing lots of small writes is bad for performance, so buffer here and
+     * only write data when we've accumulated a large chunk of data. Use our
+     * own buffer here, rather than the connection IO buffer, since we don't
+     * want to use as much memory as a single message. */
+    static char *buffer;
+    static size_t buflen;
+    char *bufptr, *msg = NULL;
+
+    if (!buffer) buffer = xmalloc(buflen = 32768);
+    bufptr = buffer;
+
+#define buffer_push(sa, na) \
+        do { \
+            char *s; \
+            size_t n; \
+            s = sa; \
+            n = na; \
+            /* Unlikely but must deal with this case. */ \
+            if (n > buflen) { \
+                if (bufptr > buffer && !connection_send(c, buffer, bufptr - buffer)) \
+                    goto write_failure; \
+                bufptr = buffer; \
+                if (!connection_send(c, s, n)) \
+                    goto write_failure; \
+            } else { \
+                if ((bufptr + n) > (buffer + buflen)) { \
+                    if (!connection_send(c, buffer, bufptr - buffer)) \
+                        goto write_failure; \
+                    bufptr = buffer; \
+                } \
+                memcpy(bufptr, s, n); \
+                bufptr += n; \
+            } \
+            nwritten += n; \
+        } while (0)
+
     offset = msgoffset - (msgoffset % PAGESIZE);
     length = (msgoffset + msglength + PAGESIZE) ;
     length -= length % PAGESIZE;
@@ -451,8 +500,9 @@
         return -1; /* Failure before +OK sent. */
     }
 
-    connection_sendresponse(c, 1, _("Message follows"));
-    
+    msg = _("+OK Message follows\r\n");
+    buffer_push(msg, strlen(msg));
+
     /* Find the beginning of the message headers */
     p = filemem + (msgoffset % PAGESIZE);
     r = p + msglength;
@@ -465,14 +515,12 @@
         errno = 0;
         
         /* Escape a leading ., if present. */
-        if (*p == '.' && !connection_send(c, ".", 1))
-            goto write_failure;
-        ++nwritten;
+        if (*p == '.')
+            buffer_push(".", 1);
         
         /* Send line itself. */
-        if (!connection_send(c, p, q - p) || !connection_send(c, "\r\n", 2))
-            goto write_failure;
-        nwritten += q - p + 2;
+        buffer_push(p, q - p);
+        buffer_push("\r\n", 2);
 
         p = q + 1;
     }
@@ -480,11 +528,7 @@
     ++p;
 
     errno = 0;
-    if (!connection_send(c, "\r\n", 2)) {
-        log_print(LOG_ERR, _("connection_sendmessage: send failure"));
-        munmap(filemem, length);
-        return -2;
-    }
+    buffer_push("\r\n", 2);
     
     /* Now send the message itself */
     while (p < r && n) {
@@ -495,27 +539,31 @@
         errno = 0;
 
         /* Escape a leading ., if present. */
-        if (*p == '.' && !connection_send(c, ".", 1))
-            goto write_failure;
-        ++nwritten;
+        if (*p == '.')
+            buffer_push(".", 1);
         
         /* Send line itself. */
-        if (!connection_send(c, p, q - p) || !connection_send(c, "\r\n", 2))
-            goto write_failure;
-        nwritten += q - p + 2;
+        buffer_push(p, q - p);
+        buffer_push("\r\n", 2);
 
         p = q + 1;
     }
+
+    /* Finish up. */
+    buffer_push(".\r\n", 3);
+
+    if (bufptr > buffer && !connection_send(c, buffer, bufptr - buffer))
+        goto write_failure;
+    
     if (munmap(filemem, length) == -1)
         log_print(LOG_ERR, "connection_sendmessage: munmap: %m");
     
     errno = 0;
 
-    if (!connection_send(c, ".\r\n", 3)) {
-        log_print(LOG_ERR, _("connection_sendmessage: send failure"));
-        return -2;
-    } else return nwritten + 3;
+    return nwritten + 3;
 
+#undef buffer_push
+    
 write_failure:
     log_print(LOG_ERR, _("connection_sendmessage: send failure"));
     munmap(filemem, length);
Index: tpop3d/ioabs_tls.c
diff -u tpop3d/ioabs_tls.c:1.14 tpop3d/ioabs_tls.c:1.15
--- tpop3d/ioabs_tls.c:1.14	Mon Nov 24 19:58:28 2003
+++ tpop3d/ioabs_tls.c	Sun Jun 20 00:06:30 2004
@@ -11,7 +11,7 @@
 
 #ifdef USE_TLS
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h>
 
@@ -276,14 +276,12 @@
                     return 0;
 
                 case SSL_ERROR_SYSCALL:
-                    if (!e) {
-                        if (ERR_get_error() == 0)
-                            log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: connection unexpectedly closed by peer"), c->idstr);
-                        else
-                            log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: %m; closing connection"), c->idstr);
-                        break;
-                    }
-                    /* fall through */
+                    if (ERR_get_error() == 0)
+                        log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: connection unexpectedly closed by peer"), c->idstr);
+                    else
+                        log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: %m; closing connection"), c->idstr);
+                    break;
+                        
                 case SSL_ERROR_SSL:
                 default:
                     log_print(LOG_ERR, _("ioabs_tls_post_select: client %s: SSL_accept: %s; closing connection"), c->idstr, ERR_reason_error_string(ERR_get_error()));
Index: tpop3d/maildir.c
diff -u tpop3d/maildir.c:1.19 tpop3d/maildir.c:1.26
--- tpop3d/maildir.c:1.19	Mon Nov 24 20:23:20 2003
+++ tpop3d/maildir.c	Fri Sep 24 00:13:46 2004
@@ -13,7 +13,7 @@
 
 #ifdef MBOX_MAILDIR
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #include <sys/types.h>
 
@@ -145,10 +145,10 @@
 }
 
 /* maildir_build_index MAILDIR SUBDIR TIME
- * Build an index of the MAILDIR; SUBDIRis one of cur, tmp or new; TIME is the
+ * Build an index of the MAILDIR; SUBDIR is one of cur, tmp or new; TIME is the
  * time at which the operation started, used to ignore messages delivered
- * during processes. Returns 0 on success, -1 otherwise. */
-int maildir_build_index(mailbox M, const char *subdir, time_t time) {
+ * during processing. Returns 0 on success, -1 otherwise. */
+int maildir_build_index(mailbox M, const char *subdir, time_t T) {
     DIR *dir;
     struct dirent *d;
 
@@ -156,7 +156,7 @@
 
     dir = opendir(subdir);
     if (!dir) {
-        log_print(LOG_ERR, "maildir_build_index: opendir(%s): %m", subdir);
+        log_print(LOG_ERR, "maildir_build_index: opendir(%s/%s): %m", M->name, subdir);
         return -1;
     }
     
@@ -168,11 +168,19 @@
         filename = xmalloc(strlen(subdir) + strlen(d->d_name) + 2);
         sprintf(filename, "%s/%s", subdir, d->d_name);
         if (!filename) return -1;
-        if (stat(filename, &st) == 0 && st.st_mtime < time) {
-            /* These get sorted by mtime later. */
+        if (0 == stat(filename, &st)) {
             struct indexpoint pt;
+
+            /* XXX Previously, we ignored messages from the future, since
+             * that's what qmail-pop3d does. But it's not clear why this is
+             * useful, so turn the check into a warning. */
+            if (st.st_mtime > T)
+                log_print(LOG_WARNING, _("maildir_build_index: %s: mtime is %d seconds in the future; this condition may indicate that you have a clock synchronisation error, especially if you are using NFS-mounted mail directories"), filename, (int)(st.st_mtime - T));
+            
+            /* These get sorted by mtime later. */
             maildir_make_indexpoint(&pt, filename, st.st_size, st.st_mtime);
             mailbox_add_indexpoint(M, &pt);
+
             /* Accumulate size of messages. */
             M->totalsize += st.st_size;
         }
@@ -192,6 +200,86 @@
     return 0;
 }
 
+/* maildir_recurse MAILBOX DIRECTORY TIME
+ * Recurses through IMAP folders to search for messages.  Returns 0 on success
+ * and minor errors, -1 on fatal errors. */
+static int maildir_recurse(mailbox M, char *current, time_t time) {
+    DIR *dir;
+    struct dirent *d;
+    char *folder, *ignorefolders, *match, *recursefolder;
+    int foldersl, dirl;
+    struct stat st;
+
+    if (!M) return -1;
+
+    dir = opendir(current);
+    if (!dir) {
+        /* We ignore subdirectories with errors, therefor we return 0 here. */
+        log_print(LOG_ERR, "maildir_recurse: opendir(.): %m");
+        return 0;
+    }
+
+    if (!(ignorefolders = config_get_string("maildir-ignore-folders")))
+        ignorefolders = "Trash Sent";
+
+    while ((d = readdir(dir))) {
+        if (d->d_name[0] != '.')
+            continue;
+
+        folder = d->d_name + 1;
+        if (!*folder || !strcmp(".", folder))
+            continue;
+
+        foldersl = strlen(folder);
+
+        for (match = ignorefolders;; match++) {
+            match = strstr(match, folder);
+            if (!match) {
+                dirl = strlen(current) + foldersl + 3;
+
+                recursefolder = xmalloc(dirl);
+                if (!recursefolder)
+                    return -1;
+
+                sprintf(recursefolder, "%s/.%s", current, folder);
+
+                if(stat(recursefolder, &st) == 0 && S_ISDIR(st.st_mode)) {
+                    if(maildir_recurse(M, recursefolder, time) != 0) {
+                        xfree(recursefolder);
+                        return -1;
+                    }
+
+                    recursefolder = xrealloc(recursefolder, dirl + 4);
+                    if (!recursefolder)
+                        return -1;
+
+                    /* We ignore subdirectories with errors, therefore we don't
+                     * fail on maildir_build_index problems here. */
+                    sprintf(recursefolder, "%s/.%s/new", current, folder);
+                    if (stat(recursefolder, &st) == 0 && S_ISDIR(st.st_mode))
+                        maildir_build_index(M, recursefolder, time);
+
+                    sprintf(recursefolder, "%s/.%s/cur", current, folder);
+                    if (stat(recursefolder, &st) == 0 && S_ISDIR(st.st_mode))
+                        maildir_build_index(M, recursefolder, time);
+                }
+
+                xfree(recursefolder);
+                break;
+            }
+            if (match != ignorefolders && match[-1] != ' ')
+                continue;
+            if (match[foldersl] && match[foldersl] != ' ')
+                continue;
+            break;
+        }
+    }
+
+    closedir(dir);
+    return 0;
+}
+
+
 /* maildir_sort_callback A B
  * qsort(3) callback for ordering messages in a maildir. */
 int maildir_sort_callback(const void *a, const void *b) {
@@ -205,7 +293,7 @@
     mailbox M, failM = NULL;
     struct timeval tv1, tv2;
     float f;
-    int locked;
+    int locked = 0;
  
     alloc_struct(_mailbox, M);
     
@@ -235,6 +323,7 @@
     /* Build index of maildir. */
     if (maildir_build_index(M, "new", tv1.tv_sec) != 0) goto fail;
     if (maildir_build_index(M, "cur", tv1.tv_sec) != 0) goto fail;
+    if (config_get_bool("maildir-recursion") && maildir_recurse(M, ".", tv1.tv_sec) != 0) goto fail;
 
     /* Now sort the messages. */
     qsort(M->index, M->num, sizeof(struct indexpoint), maildir_sort_callback);
@@ -247,8 +336,10 @@
 
 fail:
     if (M) {
-        if (locked) maildir_unlock(M->name);
-        if (M->name) xfree(M->name);
+        if (M->name) {
+            if (locked) maildir_unlock(M->name);
+            xfree(M->name);
+        }
         if (M->index) xfree(M->index);
         xfree(M);
     }
Index: tpop3d/netloop.c
diff -u tpop3d/netloop.c:1.10 tpop3d/netloop.c:1.13
--- tpop3d/netloop.c:1.10	Mon Nov 24 19:58:28 2003
+++ tpop3d/netloop.c	Tue Oct  5 11:51:21 2004
@@ -7,7 +7,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -41,7 +41,7 @@
 /* The socket send buffer is set to this, so that we don't end up in a
  * position that we send so much data that the client will not have received
  * all of it before we time them out. */
-#define MAX_DATA_IN_FLIGHT      8192
+#define DEFAULT_TCP_SEND_BUFFER     16384
 
 int max_running_children = 16;          /* How many children may exist at once. */
 volatile int num_running_children = 0;  /* How many children are active. */
@@ -124,9 +124,20 @@
         if (FD_ISSET(L->s, readfds)) {
             struct sockaddr_in sin, sinlocal;
             size_t l = sizeof(sin);
-            int s, a = MAX_DATA_IN_FLIGHT;
+            static int tcp_send_buf = -1;
+            int s;
             time_t start;
 
+            if (tcp_send_buf == -1) {
+                int q;
+                q = config_get_int("tcp-send-buffer", &tcp_send_buf);
+                if (q <= 0 || tcp_send_buf < 0) {
+                    tcp_send_buf = DEFAULT_TCP_SEND_BUFFER;
+                    if (q == -1 || tcp_send_buf < 0)
+                        log_print(LOG_WARNING, "listeners_post_select: bad value for tcp-send-buffer; using default");
+                }
+            }
+
             time(&start);
             errno = 0;
             
@@ -144,7 +155,8 @@
                     close(s);
                 }
 #endif
-                else if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &a, sizeof(a)) == -1) {
+                else if (tcp_send_buf != 0
+                         && setsockopt(s, SOL_SOCKET, SO_SNDBUF, &tcp_send_buf, sizeof(tcp_send_buf)) == -1) {
                     /* Set a small send buffer so that we get EAGAIN if the client
                      * isn't acking our data. */
                     log_print(LOG_ERR, "listeners_post_select: setsockopt: %m");
@@ -363,11 +375,11 @@
 /* connections_post_select:
  * Called after the main select(2) to do stuff with connections.
  *
- * For each connection, we call its own post_select routine. This will do all sorts
- * of stuff which is hidden to us, including pushing the running/closing/closed
- * state machine around and reading and writing the I/O buffers. We need to try to
- * parse commands when it's indicated that data have been read, and react to the
- * changed state of any connection. */
+ * For each connection, we call its own post_select routine. This will do all
+ * sorts of stuff which is hidden to us, including pushing the
+ * running/closing/closed state machine around and reading and writing the I/O
+ * buffers. We need to try to parse commands when it's indicated that data have
+ * been read, and react to the changed state of any connection. */
 static void connections_post_select(fd_set *readfds, fd_set *writefds, fd_set *exceptfds) {
     static size_t i;
     size_t i0;
@@ -382,12 +394,14 @@
         if (!(c = connections[i]))
             continue;
 
+        if (i > 0 && post_fork) {
+            connections[0] = c;
+            connections[i] = NULL;
+        }
+
         /* Handle all post-select I/O. */
         r = c->io->post_select(c, readfds, writefds, exceptfds);
 
-        /* At this stage, the connection may be closed or closing. But we
-         * should try to interpret commands anyway, in case the client sends
-         * QUIT and immediately closes the connection. */
         if (r && !connection_isfrozen(c)) {
             /*
              * Handling of POP3 commands, and forking children to handle
@@ -426,6 +440,15 @@
                     break;
             }
 
+            if (post_fork) {
+                if (i != 0) {
+                    connections[0] = connections[i];
+                    connections[i] = NULL;
+                }
+                i = 0;
+                break;
+            }
+
             if (!c)
                 continue; /* if connection has been destroyed, do next one */
         }
@@ -462,8 +485,18 @@
         if (c->cstate == closed) {
             /* We should now log the closure of the connection and ending
              * of any authenticated session. */
-            if (c->a)
+            if (c->a) {
+                /* Microsoft Outlook closes connections immediately after
+                 * issuing QUIT. By default we'd lose any message deletions
+                 * that were pending, so add an option to apply them even
+                 * so. */
+                if (!config_get_bool("no-commit-on-early-close")) {
+                    pop3command p;
+                    if ((p = connection_parsecommand(c)) && p->cmd == QUIT)
+                        c->m->apply_changes(c->m);
+                }
                 log_print(LOG_INFO, _("connections_post_select: client %s: finished session for `%s' with %s"), c->idstr, c->a->user, c->a->auth);
+            }
             log_print(LOG_INFO, _("connections_post_select: client %s: disconnected; %d/%d bytes read/written"), c->idstr, c->nrd, c->nwr);
 
 /*            remove_connection(c);*/
@@ -473,6 +506,11 @@
             if (post_fork)
                 _exit(0);
         }
+
+        if (post_fork) {
+            i = 0;
+            break;
+        }
     }
 }
 
@@ -503,12 +541,14 @@
     /* Main select() loop */
     while (!foad) {
         fd_set readfds, writefds;
-        struct timeval tv = {1, 0}; /* Must be less than IDLE_TIMEOUT and small enough that termination on receipt of SIGTERM is timely. */
+        struct timeval tv = {0};
         int n = 0, e;
 
         FD_ZERO(&readfds);
         FD_ZERO(&writefds);
 
+        tv.tv_sec = 1;  /* must be smaller than timeout */
+
         if (!post_fork) listeners_pre_select(&n, &readfds, &writefds, NULL);
 
         connections_pre_select(&n, &readfds, &writefds, NULL);
Index: tpop3d/password.c
diff -u tpop3d/password.c:1.6 tpop3d/password.c:1.7
--- tpop3d/password.c:1.6	Tue Sep  9 22:52:30 2003
+++ tpop3d/password.c	Wed Sep 29 20:58:00 2004
@@ -31,10 +31,14 @@
 #define _XOPEN_SRC      /* crypt(3), on some systems */
 #include <unistd.h>
 
+#ifdef SHA1_PASSWORDS
+#include <openssl/sha.h>
+#endif /* SHA1_PASSWORDS */
+
 #include "md5.h"
 #include "util.h"
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 /* 
  * MD5 crypt(3) routines. This is here so that you can migrate passwords from
@@ -272,13 +276,37 @@
                 log_print(LOG_ERR, _("password: %s has password type mysql, but hash is of incorrect length %d (expecting 8 or 16)"), who, n);
                 return 0;
         }
+#ifdef SHA1_PASSWORDS
+    } else if (IS_SCHEME(pwhash, "{sha1}", default_crypt_scheme)) {
+        /* XXX Messy. We should generalise hashing, probably by just using
+         * OpenSSL's code for it. Further, this only supports hex-encoded
+         * passwords, not base64 as well, because the base64 code is tied to
+         * the MD5 code.... */
+        unsigned char h[20], hh[41];
+        SHA_CTX c;
+        int i;
+
+        if (strlen(realhash) != 40) {
+            log_print(LOG_ERR, _("password: %s has password type sha1, but has is of incorrect length"), who);
+            return 0;
+        }
+        
+        SHA1_Init(&c);
+        SHA1_Update(&c, pass, strlen(pass));
+        SHA1_Final(h, &c);
+
+        for (i = 0; i < 20; ++i)
+            sprintf(hh + 2 * i, "%02x", (unsigned int)h[i]);
+
+        return strcasecmp(realhash, hh) == 0;
+#endif /* SHA1_PASSWORDS */
     } else if (IS_SCHEME(pwhash, "{md5}", default_crypt_scheme)) {
         /* Straight MD5 password. But this might be either in hex or base64
          * encoding. */
         if (strlen(realhash) == 32) {
             /* Hex. */
             return strcasecmp(realhash, md5_digest_str(pass, strlen(pass), 0)) == 0;
-        } else if (strlen(pwhash) == 24) {
+        } else if (strlen(realhash) == 24) {
             /* Base 64. */
             return strcmp(realhash, md5_digest_str(pass, strlen(pass), 1)) == 0;
         } else
Index: tpop3d/pop3.c
diff -u tpop3d/pop3.c:1.57 tpop3d/pop3.c:1.58
--- tpop3d/pop3.c:1.57	Thu Nov  6 01:19:27 2003
+++ tpop3d/pop3.c	Tue Feb  3 19:52:03 2004
@@ -6,7 +6,7 @@
  *
  */
 
-static const char rcsid[] = "$Id$";
+static const char rcsid[] = "$Id$";
 
 #ifdef HAVE_CONFIG_H
 #include "configuration.h"
@@ -295,10 +295,10 @@
             if (verbose)
                 log_print(LOG_DEBUG, _("do_retr: client %s: sending message %d (%d bytes)"),
                         c->idstr, msg_num + 1, (int)curmsg->msglength);
-        
+            
             if ((n = c->m->sendmessage(c->m, c, msg_num, -1)) == -2)
                 return close_connection;
-            
+
             /* That might have taken a long time. */
             c->idlesince = time(NULL);
             if (verbose) {
@@ -583,6 +583,9 @@
         }
         
         switch (p->cmd) {
+            case CAPA:
+                return do_capa(c);
+
             case LIST:
                 do_list(c, msg_num);
                 break;
Index: tpop3d/pop3bench
diff -u /dev/null tpop3d/pop3bench:1.3
--- /dev/null	Tue Oct  5 12:17:53 2004
+++ tpop3d/pop3bench	Tue Feb  3 19:52:03 2004
@@ -0,0 +1,370 @@
+#!/usr/bin/perl -w
+#
+# pop3bench:
+# POP3 server benchmarking tool.
+#
+# Copyright (c) 2004 Chris Lightfoot. All rights reserved.
+# Email: chris@ex-parrot.com; WWW: http://www.ex-parrot.com/~chris/
+#
+
+my $rcsid = ''; $rcsid .= '$Id$';
+
+use Digest::MD5;
+use IO::Socket;
+
+my $have_ssl = 0;
+eval '
+    use IO::Socket::SSL;
+    $have_ssl = 1;
+';
+
+use Time::HiRes;
+use Error qw(:try);
+
+my $T = time();
+
+sub howlong () {
+    my $T2 = time();
+    $T2 -= $T;
+    $T = time();
+    return $T2;
+}
+
+# error MESSAGE
+# Print the MESSAGE to stderr.
+sub error ($) {
+    print STDERR "pop3bench: $_[0]\n";
+}
+
+# quit MESSAGE
+# Print the MESSAGE to stderr and abort.
+sub quit ($) {
+    error($_[0]);
+    exit(1);
+}
+
+# verbose OPTIONS MESSAGE
+# If enabled, print a verbose MESSAGE to stderr.
+sub verbose ($$) {
+    error($_[1]) if ($_[0]->{verbose});
+}
+
+# usage
+# Print a usage message to stdout.
+sub usage () {
+    print <<EOF;
+pop3bench: POP3 server benchmarking tool
+
+Synopsis: pop3bench --help | [options] HOST [PORT]
+
+Options:
+    --help
+        Display this message.
+
+    --verbose
+        Log debugging information.
+
+    --conversation
+        Log the conversation between client and server. Implies --verbose.
+
+    --username USER
+    --password PASSWORD
+        Specify USER and PASSWORD for authentication. Default: ask
+        interactively.
+
+    --apop
+        Use the APOP shared-secret authentication method. Default: use
+        USER/PASS.
+
+    --pipelining
+        Use command pipelining, if supported. Default: don't.
+
+    --tls
+    --stls
+        Make a TLS connection to the server; or, connect to the server
+        normally, but attempt to negotiate TLS operation using the STLS
+        command. Default: use unsecured TCP.
+
+    --commands LIST
+        Benchmark the given comma-separated LIST of commands on the server.
+        LIST may include: LIST UIDL DELE RETR TOP NOOP. Benchmarking DELE is
+        destructive, obviously. Default: LIST, UIDL, RETR.
+
+In unsecured TCP and STLS modes, the default PORT is 110; in TLS mode the
+default PORT is 995.
+
+Copyright (c) 2004 Chris Lightfoot <chris\@ex-parrot.com>
+All Rights Reserved.
+EOF
+}
+
+# parse_options ARGUMENTS
+# Return a reference to a hash with the options to be used by the program.
+sub parse_options (@) {
+    my @args = @_;
+    my $res = {
+        port => undef,
+        mode => 'tcp',
+        apop => 0,
+        pipelining => 0,
+        user => undef,
+        pass => undef,
+        commands => [qw(list uidl retr)],
+        verbose => 0,
+        conversation => 0
+    };
+    
+    while (@args && $args[0] =~ /^--(.+)/) {
+        shift(@args);
+        if ($1 eq 'help') {
+            usage();
+            exit(0);
+        } elsif ($1 eq 'verbose') {
+            $res->{verbose} = 1;
+        } elsif ($1 eq 'conversation') {
+            $res->{conversation} = $res->{verbose} = 1;
+        } elsif ($1 eq 'username') {
+            $res->{user} = shift(@args);
+        } elsif ($1 eq 'password') {
+            $res->{pass} = shift(@args);
+        } elsif ($1 eq 'apop') {
+            $res->{apop} = 1;
+        } elsif ($1 eq 'pipelining') {
+            $res->{pipelining} = 1;
+        } elsif ($1 eq 'commands') {
+            my %allowed = map { $_ => 1 } qw(list uidl dele retr top noop);
+            $res->{commands} = [ ];
+            foreach (split(/,\s*/, shift(@args))) {
+                $_ = lc($_);
+                return "`$_' is not a known command" unless (exists($allowed{$_}));
+                push(@{$res->{commands}}, $_);
+            }
+        } elsif ($1 =~ /^(s?tls)$/) {
+            return "specify at most one of --tls, --stls" if ($res->{mode} ne 'tcp');
+            $res->{mode} = $1;
+        } else {
+            return "`--$1': unknown option";
+        }
+    }
+
+    return "arguments are host and optional port" if (@args > 2 || @args == 0);
+
+    $res->{host} = shift(@args);
+    $res->{port} = shift(@args) if (@args);
+
+    # Default port differs between TCP and TLS modes.
+    if (!defined($res->{port})) {
+        if ($res->{mode} eq 'tls') {
+            $res->{port} = 995;
+        } else {
+            $res->{port} = 110;
+        }
+    }
+
+    return $res;
+}
+
+# get_pop3_line OPTIONS SOCKET
+# Return a POP3 response line read from SOCKET, or undef on failure.
+sub get_pop3_line ($$) {
+    my ($opts, $s) = @_;
+    local $/ = "\r\n";
+    my $x = $s->getline() or throw Error::Simple("read: $!");
+    chomp($x);
+    return $x;
+}
+
+# get_pop3_resp OPTIONS SOCKET
+# Get a POP3 response line, and return 1 if it starts +OK, 0 if -ERR, or throw
+# an exception on error.
+sub get_pop3_resp ($$) {
+    my ($opts, $s) = @_;
+    my $r = get_pop3_line($opts, $s);
+    verbose($opts, "<-- $r") if ($opts->{conversation});
+    if ($r =~ /^\+OK/) {
+        return 1;
+    } elsif ($r =~ /^-ERR/) {
+        return 0;
+    } else {
+        throw Error::Simple("bad response line `$r'");
+    }
+}
+
+# send_pop3_cmd OPTIONS SOCKET COMMAND
+# Send COMMAND to SOCKET.
+sub send_pop3_cmd ($$$) {
+    my ($opts, $s, $cmd) = @_;
+    $s->print("$cmd\r\n") or throw Error::Simple("write: $!");
+    if ($opts->{conversation}) {
+        if ($cmd =~ /^PASS /i) {
+            verbose($opts, "--> PASS [...]");
+        } else {
+            verbose($opts, "--> $cmd");
+        }
+    }
+}
+
+# get_pop3_multiline_resp OPTIONS SOCKET [DISCARD]
+# Get a multiline response from the server. If DISCARD is true, just count the
+# lines and return the total. Otherwise return the response as a list of lines.
+# DISCARD is assumed to be true when called in scalar context;
+sub get_pop3_multiline_resp ($$;$) {
+    my ($opts, $s, $discard) = @_;
+    $discard ||= wantarray;
+    throw Error::Simple("bad response") if (!get_pop3_resp($opts, $s));
+    my @list;
+    my $N = 0;
+    while (($_ = get_pop3_line($opts, $s)) ne '.') {
+        if ($discard) {
+            ++$N;
+        } else {
+            push(@list, $_);
+        }
+    }
+    if ($opts->{conversation}) {
+        verbose($opts, "<-- ... " . scalar(@list) . " lines ...");
+        verbose($opts, "<-- .");
+    }
+    if ($discard) {
+        return $N;
+    } else {
+        return @list;
+    }
+}
+
+# connect_to_server OPTIONS
+# Return a socket connected to the server, per OPTIONS.
+sub connect_to_server ($) {
+    my $opts = shift;
+    my $s;
+    verbose($opts, "connecting to $opts->{host}:$opts->{port}");
+    if ($opts->{mode} ne 'tls') {
+        $s = new IO::Socket::INET("$opts->{host}:$opts->{port}");
+    } else {
+        $s = new IO::Socket::SSL("$opts->{host}:$opts->{port}");
+    }
+    
+    throw Error::Simple("connect: $!") unless (defined($s));
+
+    try {
+        my $banner = get_pop3_line($opts, $s);
+        if (!$banner) {
+            throw Error::Simple("no banner response from server");
+        } elsif ($banner !~ /^\+OK/) {
+            throw Error::Simple("bad banner response `$banner'");
+        }
+
+        if ($banner =~ m#<([^>]+)>#) {
+            $opts->{timestamp} = $1;
+        }
+
+        if ($opts->{mode} eq 'stls') {
+            verbose($opts, "enabling STLS mode");
+            send_pop3_cmd($opts, $s, "STLS");
+            if (!get_pop3_resp($opts, $s)) {
+                throw Error::Simple("negative STLS response");
+            } else {
+                verbose($opts, "beginning TLS negotiation");
+                IO::Socket::SSL->start_SSL($s);
+                if (ref($s) ne 'IO::Socket::SSL') {
+                    throw Error::Simple("TLS negotiation failed");
+                }
+                verbose($opts, "TLS negotiation successful");
+            }
+        }
+    } otherwise {
+        my $E = shift;
+        $s->close();
+        throw $E;
+    };
+
+    return $s;
+}
+
+# do_login OPTIONS SOCKET
+# Log in to the server by USER/PASS or APOP as appropriate. Return the number
+# of messages available, by doing a LIST.
+sub do_login ($$) {
+    my ($opts, $s) = @_;
+    if ($opts->{apop}) {
+        throw Error::Simple("can't do APOP login since server did not send a timestamp") if (!exists($opts->{timestamp}));
+        verbose($opts, "sending APOP login command");
+        my $digest = Digest::MD5::md5_hex($opts->{timestamp} . $opts->{user});
+        send_pop3_cmd($opts, $s, "APOP $opts->{user} $digest");
+        throw Error::Simple("negative APOP response (login failed)") if (!get_pop3_resp($opts, $s));
+    } else {
+        verbose($opts, "sending USER/PASS login commands");
+        send_pop3_cmd($opts, $s, "USER $opts->{user}");
+        send_pop3_cmd($opts, $s, "PASS $opts->{pass}") if ($opts->{pipelining});
+        throw Error::Simple("negative USER response") if (!get_pop3_resp($opts, $s));
+        send_pop3_cmd($opts, $s, "PASS $opts->{pass}") unless ($opts->{pipelining});
+        throw Error::Simple("negative PASS response (login failed)") if (!get_pop3_resp($opts, $s));
+    }
+    verbose($opts, "login successful; retrieving list of messages");
+    send_pop3_cmd($opts, $s, "LIST");
+    my $n = get_pop3_multiline_resp($opts, $s);
+    verbose($opts, "$n messages available");
+    return $n;
+}
+
+# do_quit OPTIONS SOCKET
+# Log out and shut down the connection on SOCKET.
+sub do_quit ($$) {
+    my ($opts, $s) = @_;
+    verbose($opts, "logging out");
+    send_pop3_cmd($opts, $s, "QUIT");
+    error("negative QUIT response (bad, not fatal)") if (!get_pop3_resp($opts, $s));
+    verbose($opts, "closing connection");
+    $s->shutdown(2);
+    $s->close();
+    verbose($opts, "done");
+}
+
+my $opts = parse_options(@ARGV);
+
+if (!ref($opts)) {
+    quit($opts);
+    exit(1);
+}
+
+if ($opts->{mode} ne 'tcp' && !$have_ssl) {
+    quit("$opts->{mode} requested, but no IO::Socket::SSL");
+}
+
+# If not specified on command line, get username and password.
+if (!defined($opts->{user})) {
+    $| = 1;
+    print "Username: ";
+    my $u = STDIN->getline();
+    quit("you must give a username") if (!defined($u));
+    chomp($u);
+    $u =~ s/^\s+//;
+    $u =~ s/\s+$//;
+    quit("you must give a username") if (length($u) == 0);
+    $| = 0;
+    $opts->{user} = $u;
+}
+
+if (!defined($opts->{pass})) {
+    $| = 1;
+    print "Password: ";
+    system("stty", "-echo");
+    my $p = STDIN->getline();
+    quit("you must give a password") if (!defined($p));
+    chomp($p);
+    $p =~ s/^\s+//;
+    $p =~ s/\s+$//;
+    system("stty", "echo");
+    print "\n";
+    $| = 0;
+    $opts->{pass} = $p;
+}
+
+try {
+    my $s = connect_to_server($opts);
+    do_login($opts, $s);
+    do_quit($opts, $s);
+} catch Error::Simple with {
+    my $E = shift;
+    quit($E->text());
+}
Index: tpop3d/tpop3d.conf.5
diff -u tpop3d/tpop3d.conf.5:1.47 tpop3d/tpop3d.conf.5:1.51
--- tpop3d/tpop3d.conf.5:1.47	Mon Nov 24 19:58:28 2003
+++ tpop3d/tpop3d.conf.5	Tue Oct  5 11:51:21 2004
@@ -142,6 +142,16 @@
 timeout), then specify 600 seconds. This may be necessary with some clients
 which pause randomly whilst downloading messages.
 .TP
+\fBtcp-send-buffer\fp: \fInumber\fP
+This is the largest number of bytes which may be `in flight' between the server
+and a client at any time. Setting this to larger values may improve the
+performance of \fBtpop3d\fP, but at the risk of timing out clients connected by
+slow networks. You should not set this parameter to anything larger than the
+timeout multiplied by the data rate (in bytes per second) of the slowest
+network through which clients will connect to the POP3 server. This is set using
+the SO_SNDBUF socket option; see \fBsocket\fP(7) for more information. The
+default is 16,384 bytes; set this to 0 to use the system default.
+.TP
 \fBlog-facility\fP: \fIfacility\fP
 This selects the `facility' as which \fBtpop3d\fP emits system log messages.
 Possible values for \fIfacility\fP are: \fBmail\fP, \fBauthpriv\fP,
@@ -236,6 +246,21 @@
 RFC1939. Even if not specified, \fBtpop3d\fP behaves intelligently when a
 message in a maildir is moved or deleted, so this option is not necessary.
 .TP
+\fBmaildir-recursion\fP: (\fByes\fP|\fBtrue\fP)
+Tells \fBtpop3d\fP to display messages in IMAP folders as if they were in the
+INBOX. Useful if you mix POP3 with IMAP clients such as webmail systems.
+.TP
+\fBmaildir-ignore-folders\fP: [foldername [...]]
+Specifies IMAP folders (without the leading dot) that should be excluded from
+\fBmaildir-recursion\fP. May be empty; more than one folder should be separated
+by spaces (not tabs).
+
+The default is:
+.nf
+  maildir-ignore-folders: Trash Sent
+.fi
+
+.TP
 .nf
 \fBtcp-wrappers-name\fP: \fIname\fP
 .fi
@@ -342,7 +367,17 @@
 Log incorrect passwords supplied by users who fail to log in. Use of this
 option is an invasion of privacy, but may be useful for debugging client
 configuration problems.
+.TP
+\fBno-commit-on-early-close\fP: (\fByes\fP|\fBtrue\fP)
+Some POP3 clients (most notably Microsoft `Outlook') will close their
+connection to the server immediately after issuing a QUIT command and before
+receiving any response. Strictly they oughtn't to do that, and historically if
+they did, \fBtpop3d\fP would abort the connection and not delete messages for
+which DELE commands had been issued during the session. That behaviour has been
+changed for greater compatibility with broken clients; you can set this option
+to restore the previous behaviour. Doing so will reduce the chance that your
+clients will lose mail due to flakey network connectivity.
 .PP
 \fBtpop3d\fP can cache the results of successful login attempts, and re-use
 them when the same user logs in again. This is probably not useful except
 for servers which run under very heavy load. Authentication cacheing can only

